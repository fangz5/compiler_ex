2.2.1) Consider the context-free grammer S -> S S + | S S * | a
a) Show how the string aa+a* can be generated by this grammar.
(aa+)(a)*

b) Construct a parse tree for this string.
             S
           / | \
           S a  *
         / | \
        a  a  +

c) What language does this grammer generate? Justify your answer.
Postfix arithmetic using + and *.


2.2.2) What language is generated by the following grammers? In each case justify your answer.
a) S -> 0 S 1 | 0 1
Sequences made of n 0's followed by n 1's, n = 1, 2, 3, ...

b) S -> + S S | - S S | a
Combinations of binary operations (+, -) about non-terminal a.

c) S -> S (S) S | eps
Set of matched and nested parenthesis.

d) S -> a S b S | b S a S | eps
Sequences of equal numbers of a's and b's.

e) S -> a | S + S | S S | S * | (S)
As it was defined by the rules ...


2.2.3) Which of the grammers in 2.2.2 are ambiguous?
c) ()()()

d) ababab => a ba b ab   or    a baba b

e) aaaaa


2.2.4) Construct unambiguous context-free grammers for each of the following languages. In each case show
that your grammar is correct.
a) Arithmetic expressions in postfix notation.
S -> S S + | S S - | S S * | S S / | num

b) Left-associative lists of identifiers separated by commas.
lists -> lists , id | id

c) Right-associative lists of identifiers separated by commas.
lists -> id , lists | id

d) Arithmetic expressions of integers and identifiers with the four binary operators +, -, *, /.
expr -> expr expr op | int | id
op -> + | - | * | /
----------------------------
expr -> expr + expr | expr - expr | term
term -> term * term | term / term | factor
factor -> int | id | (expr)

!e) Add unary plus and minus to the arithmetic operators of (d).
expr -> expr + expr | expr - expr | term
term -> term * term | term / term | unary
unary -> + factor | - factor | factor
factor -> int | id | (expr)


2.2.5)
a) Show that all binary strings generated by the following grammer have values divisible by 3.
		num -> 11 | 1001 | num 0 | num num
Proof. i) Trivial for 11 and 1001.
ii) Assume num is divisible by 3, then 
	(1) num 0 in binary is actually 2 * num, divisible by 3;
	(2) num num = num 0 ... 0 + num, divisible by 3.
By mathematic deduction, num is divisible by 3.

b) Does the grammar generate all binary strings with values divisible by 3?
No. 21 = 10101 cannot be generated.


2.2.6) Construct a context-free grammer for roman numericals.
thousands = p(M, V-bar, X-bar) hundreds
hundreds = p(C, D, M) tens
tens = p(X, L, C) digits
digits = p(I, V, X) | eps
p(A, B, C) -> A | AA | AAA | AB | B | BA | BAA | BAAA | AC